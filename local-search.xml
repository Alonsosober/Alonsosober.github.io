<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>消除左递归</title>
    <link href="/2024/10/09/%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92/"/>
    <url>/2024/10/09/%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h3 id="消除左递归的原因">消除左递归的原因</h3><blockquote><p>自顶向下分析的递归下降分析基本思想是将每个非终结符定义为一个函数，调用该函数时会尝试逐步匹配输入串的内容，是一个递归调用的过程</p><p>例:</p><p><span class="math inline">\(S \to AB \\ A \to a|\epsilon\\B\to b|\epsilon\)</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">S</span><span class="hljs-params">()</span> &#123;<br>    A();  <span class="hljs-comment">// 解析 A</span><br>    B();  <span class="hljs-comment">// 解析 B</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (lookahead == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;  <span class="hljs-comment">// 如果下一个字符是 &#x27;a&#x27;</span><br>        match(<span class="hljs-string">&#x27;a&#x27;</span>);          <span class="hljs-comment">// 匹配 &#x27;a&#x27;</span><br>    &#125;<br>    <span class="hljs-comment">// 否则 A 推导为空，什么都不做（对应于 A -&gt; epsilon）</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (lookahead == <span class="hljs-string">&#x27;b&#x27;</span>) &#123;  <span class="hljs-comment">// 如果下一个字符是 &#x27;b&#x27;</span><br>        match(<span class="hljs-string">&#x27;b&#x27;</span>);          <span class="hljs-comment">// 匹配 &#x27;b&#x27;</span><br>    &#125;<br>    <span class="hljs-comment">// 否则 B 推导为空，什么都不做（对应于 B -&gt; epsilon）</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果有左递归文法，则会无限递归调用某个函数，无法正常解析</p></blockquote><h3 id="消除立即左递归">消除立即左递归</h3><p><span class="math inline">\(A \to A\alpha_1 | A\alpha_2 |...| A\alpha_m|\beta_1|\beta_2|...|\beta_n\)</span></p><p><em>可以直接根据最终推导出的串来理解，比较简单</em></p><p><span class="math inline">\(A \to \beta_1A&#39; | \beta_2A&#39;|...|\beta_3A&#39;\)</span></p><p><span class="math inline">\(A&#39; \to \alpha_1A&#39;|\alpha_2A&#39;|...|\alpha_mA&#39;|\epsilon\)</span></p><p><em>多步同理，只需保证不会产生多步左递归</em></p><blockquote><p><span class="math inline">\(E \to E+T|T \\ T \to T*F|F \\ F \to(E)|id\)</span></p><p>转换</p><p><span class="math inline">\(E \to TE&#39; \\ E&#39; \to +TE&#39;|\epsilon \\ T \to FT&#39; \\ T&#39; \to * FT&#39; | \epsilon \\ F \to (E)|id\)</span></p></blockquote><h3 id="消除多步左递归">消除多步左递归</h3><p>多步推导可能产生左递归</p><blockquote><p><span class="math inline">\(S \to Aa|b, \ A \to Ac |Sd | \epsilon\)</span></p></blockquote><p>消除算法</p><ul><li><p>输入：无环：不存在<span class="math inline">\(A_i \Rightarrow^{+} A_i\)</span></p></li><li><p>输出：等价的无左递归的文法</p></li><li><p>原理:</p><ul><li>给非终结符排序，<span class="math inline">\(A_1,A_2,...,A_n\)</span></li><li>如果只有<span class="math inline">\(A_i \Rightarrow A_j(i&lt;j),不会有左递归\)</span></li><li>如果发现<span class="math inline">\(A_i \Rightarrow A_j (i&gt;j)\)</span>,代入<span class="math inline">\(A_j\)</span>的产生式,若替换后有<span class="math inline">\(A_i\)</span>的直接左递归，再消除</li></ul></li><li><p>应用：</p><p>将文法的非终结符号任意排序位<span class="math inline">\(A_1,A_2,...,A_{n}\)</span></p><p>for i = 1 to n do{</p><p>​ for j = 1 to i = 1 do{</p><p>​ <span class="math inline">\(将形如A_{i} \to A_j\gamma的产生式替换为A_i \to \delta_1\gamma|\delta_2\gamma|...|\delta_k\gamma\)</span></p><p>​ <span class="math inline">\(其中A_j \to \delta_1|\delta_2|...|\delta_k是以A_j为左部的所有产生式;\)</span></p><p>​ }</p><p>​ 消除<span class="math inline">\(A_i\)</span>的立即左递归</p><p>}</p></li></ul><blockquote><p>例：</p><p><span class="math inline">\(S \to Aa|b, \ A \to Ac |Sd | \epsilon\)</span></p><p>排序：<span class="math inline">\(S\ A\)</span></p><p>替换：</p><ul><li><span class="math inline">\(i = 1,没有处理\)</span></li><li><span class="math inline">\(i = 2,替换A \to Sd 中的S，得到A \to Ac|Aad|bd|\epsilon\)</span></li></ul><p>消除立即左递归：</p><p><span class="math inline">\(S \to Aa|b \\ A \to bdA&#39; |A&#39; \\ A&#39; \to cA&#39; | ad A&#39; | \epsilon\)</span></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>两个信封之谜</title>
    <link href="/2024/08/13/two%20envelops/"/>
    <url>/2024/08/13/two%20envelops/</url>
    
    <content type="html"><![CDATA[<ul><li>[<strong>Two evelopes</strong>] You are handed two envelopes. and you know that each contains a positive integer dollar amount and that the two amounts are different. The values of these two amounts are modeled as constants that are unknown. Without knowing what the amounts are, you select at random one of the two envelopes, and after looking at the amount inside, you may switch envelopes if you wish. A friend claims that the following strategy will increase above <span class="math inline">\(\frac{1}{2}\)</span> your probability of ending up with the envelope with the larger amount: toss a coin repeatedly. let <span class="math inline">\(\mathrm{X}\)</span> be equal to <span class="math inline">\(\frac{1}{2}\)</span> plus the number of tosses required to obtain heads for the first time, and switch if the amount in the envelope you selected is less than the value of <span class="math inline">\(\mathrm{X}\)</span>. Is your friend correct?</li></ul><blockquote><p><span class="math inline">\(假设两个信封中较少的钱数为m1,较多的钱数为m2\)</span></p><p><span class="math inline">\(假设事件A:第一次选择了m1,事件B:第一次选择了m2\)</span></p><p><span class="math inline">\(事件C:抛硬币后选择换，事件D:抛硬币后选择不换\)</span></p><p><span class="math inline">\(事件E_1:X&lt;m1,事件E_2:m1 \leq X &lt; m2,事件E_3:m2 \leq X\)</span></p><p><span class="math inline">\(事件F:最终拿到了m2\)</span></p><p><span class="math display">\[ \begin{flalign*} \mathrm{Pr}(F) &amp;= \mathrm{Pr}(A)\mathrm{Pr}(C|A) + \mathrm{Pr}(B)\mathrm{Pr}(D|B) \\ &amp;= \frac{1}{2}(\mathrm{Pr}(E_2)+\mathrm{Pr}(E_3)) + \frac{1}{2}(\mathrm{Pr}(E_1)+\mathrm{Pr}(E_2)) \\ &amp;= \frac{1}{2}(\mathrm{Pr}(E_1)+\mathrm{Pr}(E_2)+\mathrm{Pr}(E_3)) + \frac{1}{2}\mathrm{Pr}(E_2) \\ &amp;= \frac{1}{2} + \frac{1}{2}\mathrm{Pr}(E_2) &gt; \frac{1}{2}&amp; \end{flalign*} \]</span> 所以该策略是有利的</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
